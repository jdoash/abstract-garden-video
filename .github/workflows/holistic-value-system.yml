name: Holistic Value & Memory System

on:
  issues:
    types: [closed]

permissions:
  issues: write
  contents: read

jobs:
  calculate-holistic-value:
    runs-on: ubuntu-latest
    if: github.event.action == 'closed'
    steps:
      - name: Appraise Task Value and Collect Memory
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const issue = context.payload.issue;
              const title = issue.title.toLowerCase();
              const user = issue.assignee ? issue.assignee.login : 'Unassigned';
              
              // HOLISTIC VALUE MODEL - Every action has worth
              const holisticValues = {
                // SOFTWARE INSTALLATION (Each unlocks capability = value)
                'install maya': { base: 45, memory: 'Unlocked professional 3D creation', type: 'Foundation' },
                'install blender': { base: 35, memory: 'Gained open-source power', type: 'Foundation' },
                'install houdini': { base: 55, memory: 'Mastered procedural workflows', type: 'Foundation' },
                'install': { base: 25, memory: 'Expanded toolkit capabilities', type: 'Foundation' },
                
                // SETUP & CONFIGURATION (Time saved for future = value)
                'setup': { base: 35, memory: 'Optimized creative pipeline', type: 'Pipeline' },
                'configure': { base: 40, memory: 'Customized workflow efficiency', type: 'Pipeline' },
                'python': { base: 65, memory: 'Automated repetitive tasks', type: 'Pipeline' },
                'script': { base: 55, memory: 'Created reusable tools', type: 'Pipeline' },
                
                // LEARNING & TESTING (Knowledge = future earning potential)
                'test': { base: 30, memory: 'Validated technical skills', type: 'Learning' },
                'create sphere': { base: 20, memory: 'First 3D primitive created', type: 'Learning' },
                'tutorial': { base: 97, memory: 'Knowledge documented for others', type: 'Teaching' },
                'document': { base: 75, memory: 'Process preserved for reuse', type: 'Teaching' },
                
                // BASIC CREATION (Building blocks = cumulative value)
                'basic': { base: 45, memory: 'Foundation element crafted', type: 'Creation' },
                'simple': { base: 40, memory: 'Essential component built', type: 'Creation' },
                'primitive': { base: 35, memory: 'Core geometry established', type: 'Creation' },
                
                // ADVANCED MODELING (Complexity = premium value)
                'hero': { base: 125, memory: 'Centerpiece asset completed', type: 'Hero' },
                'complex': { base: 95, memory: 'Technical challenge conquered', type: 'Advanced' },
                'detailed': { base: 85, memory: 'Precision work delivered', type: 'Advanced' },
                'modular': { base: 105, memory: 'Reusable system designed', type: 'System' },
                
                // TEXTURING (Visual quality = market appeal)
                'texture': { base: 65, memory: 'Surface beauty achieved', type: 'Texturing' },
                'material': { base: 75, memory: 'Physical properties defined', type: 'Materials' },
                'shader': { base: 85, memory: 'Visual magic programmed', type: 'Shaders' },
                'uv': { base: 45, memory: 'Texture space optimized', type: 'Technical' },
                
                // ANIMATION (Motion = exponential value)
                'rig': { base: 115, memory: 'Life potential created', type: 'Rigging' },
                'animate': { base: 135, memory: 'Motion brought to life', type: 'Animation' },
                'dynamics': { base: 95, memory: 'Physics simulation mastered', type: 'Simulation' },
                'particle': { base: 85, memory: 'Ethereal effects generated', type: 'Effects' },
                
                // ENVIRONMENT (Complete worlds = high value)
                'environment': { base: 185, memory: 'World space constructed', type: 'Environment' },
                'landscape': { base: 165, memory: 'Natural beauty sculpted', type: 'Environment' },
                'scene': { base: 145, memory: 'Complete setting established', type: 'Scene' },
                
                // INTEGRATION (Bringing together = multiplied value)
                'integrate': { base: 125, memory: 'Systems harmonized', type: 'Integration' },
                'composite': { base: 95, memory: 'Layers unified', type: 'Compositing' },
                'final': { base: 250, memory: 'Vision fully realized', type: 'Completion' },
                'complete': { base: 225, memory: 'Project milestone achieved', type: 'Completion' },
                
                // RENDERING (Output = tangible value)
                'render': { base: 55, memory: 'Vision materialized', type: 'Output' },
                'light': { base: 65, memory: 'Mood and atmosphere created', type: 'Lighting' },
                'output': { base: 45, memory: 'Deliverable produced', type: 'Output' },
              };
              
              // Find base value and memory
              let taskValue = { base: 35, memory: 'Task completed', type: 'General' };
              for (const [key, value] of Object.entries(holisticValues)) {
                if (title.includes(key)) {
                  taskValue = value;
                  break;
                }
              }
              
              // HOLISTIC MULTIPLIERS (Everything connects)
              let multiplier = 1.0;
              
              // Sprint progression multiplier (skills compound)
              if (issue.labels.some(l => l.name === 'Sprint 1')) multiplier *= 1.0;
              if (issue.labels.some(l => l.name === 'Sprint 2')) multiplier *= 1.2;
              if (issue.labels.some(l => l.name === 'Sprint 3')) multiplier *= 1.5;
              
              // Part complexity multiplier (deeper learning)
              if (issue.labels.some(l => l.name === 'Part 1')) multiplier *= 1.0;
              if (issue.labels.some(l => l.name === 'Part 2')) multiplier *= 1.3;
              if (issue.labels.some(l => l.name === 'Part 3')) multiplier *= 1.6;
              
              // Synergy bonus (tasks build on each other)
              const allClosed = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed',
                per_page: 100
              });
              
              const taskCount = allClosed.data.length;
              if (taskCount > 10) multiplier *= 1.1; // Momentum bonus
              if (taskCount > 20) multiplier *= 1.15; // Expertise bonus
              if (taskCount > 30) multiplier *= 1.2; // Mastery bonus
              if (taskCount > 40) multiplier *= 1.25; // Authority bonus
              
              // Calculate final value
              const finalValue = Math.round(taskValue.base * multiplier);
              const xpEarned = Math.round(finalValue * 1.5); // XP higher to encourage progress
              
              // Collect memories for the journey
              const memories = [];
              for (const task of allClosed.data) {
                const taskTitle = task.title.toLowerCase();
                for (const [key, value] of Object.entries(holisticValues)) {
                  if (taskTitle.includes(key)) {
                    memories.push(value.memory);
                    break;
                  }
                }
              }
              
              // Calculate totals with compound value
              let portfolioValue = 0;
              let totalXP = 0;
              const typeBreakdown = {};
              
              for (let i = 0; i < allClosed.data.length; i++) {
                const task = allClosed.data[i];
                const taskTitle = task.title.toLowerCase();
                let value = { base: 35, memory: 'Task completed', type: 'General' };
                
                for (const [key, val] of Object.entries(holisticValues)) {
                  if (taskTitle.includes(key)) {
                    value = val;
                    break;
                  }
                }
                
                // Compound effect - later tasks worth more
                const compoundMultiplier = 1 + (i * 0.02); // 2% compound per task
                const compoundedValue = Math.round(value.base * compoundMultiplier);
                portfolioValue += compoundedValue;
                totalXP += Math.round(compoundedValue * 1.5);
                
                // Track by type
                if (!typeBreakdown[value.type]) {
                  typeBreakdown[value.type] = { count: 0, value: 0 };
                }
                typeBreakdown[value.type].count++;
                typeBreakdown[value.type].value += compoundedValue;
              }
              
              // Create value report
              let message = `# ðŸŒŸ HOLISTIC VALUE ASSESSMENT\\n\\n`;
              
              message += `## Task Contribution\\n`;
              message += `**Completed:** ${issue.title}\\n`;
              message += `**Type:** ${taskValue.type}\\n`;
              message += `**Memory Collected:** *"${taskValue.memory}"*\\n\\n`;
              
              message += `## Value Created\\n`;
              message += `ðŸ’° **Base Value:** $${taskValue.base}\\n`;
              message += `ðŸ”® **Multiplier:** ${multiplier.toFixed(1)}x\\n`;
              message += `âœ¨ **FINAL VALUE:** $${finalValue}\\n`;
              message += `â­ **XP Earned:** ${xpEarned}\\n\\n`;
              
              // Journey progress
              message += `## Your Journey (${taskCount} memories)\\n`;
              const progressBar = 'â–ˆ'.repeat(Math.min(10, Math.floor(taskCount/5))) + 'â–‘'.repeat(Math.max(0, 10 - Math.floor(taskCount/5)));
              message += `Progress: [${progressBar}] ${taskCount}/49 tasks\\n\\n`;
              
              // Recent memories (last 3)
              if (memories.length > 0) {
                message += `**Recent Memories:**\\n`;
                const recentMemories = memories.slice(-3);
                recentMemories.forEach(m => message += `â€¢ ${m}\\n`);
                message += `\\n`;
              }
              
              // Portfolio composition
              message += `## Portfolio Analysis\\n`;
              message += `**Total Value:** $${portfolioValue} (with compound growth)\\n`;
              message += `**Average per Task:** $${Math.round(portfolioValue / taskCount)}\\n`;
              message += `**Monthly Potential:** $${Math.round(portfolioValue * 0.2)}/mo\\n\\n`;
              
              message += `**Value by Type:**\\n`;
              const sortedTypes = Object.entries(typeBreakdown)
                .sort((a, b) => b[1].value - a[1].value)
                .slice(0, 5);
              
              for (const [type, data] of sortedTypes) {
                const percent = Math.round((data.value / portfolioValue) * 100);
                message += `â€¢ ${type}: $${data.value} (${percent}%)\\n`;
              }
              
              // Milestones and meaning
              message += `\\n## The Greater Whole\\n`;
              
              if (taskCount === 1) {
                message += `ðŸŒ± **First Step:** The journey of a thousand miles begins\\n`;
              } else if (taskCount === 5) {
                message += `ðŸŒ¿ **Taking Root:** Foundation skills establishing\\n`;
              } else if (taskCount === 10) {
                message += `ðŸŒ³ **Growing Strong:** Multiple disciplines mastered\\n`;
              } else if (taskCount === 20) {
                message += `ðŸŒ² **Branching Out:** Complex systems understood\\n`;
              } else if (taskCount === 30) {
                message += `ðŸŒ´ **Flourishing:** Professional capability achieved\\n`;
              } else if (taskCount === 40) {
                message += `ðŸŒº **Blooming:** Artistic vision manifesting\\n`;
              } else if (taskCount >= 49) {
                message += `ðŸ”ï¸ **Summit Reached:** The Abstract Garden is complete!\\n`;
                message += `\\nâœ¨ **All ${memories.length} memories collected form the complete vision**\\n`;
              }
              
              // Market readiness
              const marketReady = portfolioValue >= 500;
              if (marketReady) {
                message += `\\nðŸ“ˆ **Market Status:** READY FOR SALES\\n`;
                message += `Recommended platforms based on portfolio value:\\n`;
                if (portfolioValue >= 3000) {
                  message += `â€¢ TurboSquid CheckMate (Premium tier)\\n`;
                  message += `â€¢ CGTrader Pro (85% royalty eligible)\\n`;
                } else if (portfolioValue >= 1500) {
                  message += `â€¢ CGTrader (66% royalty tier)\\n`;
                  message += `â€¢ Gumroad (Direct sales)\\n`;
                } else {
                  message += `â€¢ CGTrader (Building reputation)\\n`;
                  message += `â€¢ Sketchfab (Community growth)\\n`;
                }
              }
              
              message += `\\n---\\n`;
              message += `*Each task contributes to the greater whole. Installing software enables creation,*\\n`;
              message += `*testing validates skills, and every asset adds to your marketable portfolio.*\\n`;
              message += `*Value compounds: Task #${taskCount} is worth ${Math.round((1 + (taskCount * 0.02)) * 100)}% of base.*`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: message
              });
              
            } catch (error) {
              console.error('Holistic value system error:', error.message);
            }